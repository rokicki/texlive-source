/*
 *   This file implements support for adding proper character encodings to
 *   bitmap fonts, so searching and copying text works properly in PDFs
 *   generated by the dvips Postscript output that uses bitmap fonts.
 *
 *   Written by Tomas Rokicki in June 2019.
 *
 *   It turns out we need to do more than just add encodings to the fonts
 *   for most PDF viewers, so this file also takes care of those issues.
 */
/*
 *   Our first concern is finding and reading encoding files for bitmap
 *   fonts, and, if such cannot be found, determining a reasonable
 *   alternative.
 *
 *   We could use the code in writet1 to read an encoding file, but
 *   we would need to make some messy changes for that to work, and we
 *   really want this to be a minimal impact to existing code (especially
 *   code such as write_t1 that we don't have a good handle on).
 *
 *   We want to deduplicate (combine identical) encodings to lower the
 *   memory and file size impact.  But we have to be careful; if the
 *   document requires multiple sections, we need to redownload encodings
 *   just like we do fonts.
 */
/*
 *   Reading the encodings.
 *
 *   Encodings we read are returned as an array of 256 pointers to
 *   character strings, with null for any values that are not defined.
 *   Further, we check for any explicit /.notdef entries and suppress
 *   those to null.  We read exactly one type of encoding file:  one
 *   that has precisely the following format:
 *
 *   /Encoding 256 array
 *   0 1 255 { 1 index exch /.notdef put} for
 *   dup 0 /Gamma put
 *   dup 1 /Delta put
 *   ...
 *   readonly def
 *
 *   Only characters that are defined need be in the file.  We
 *   skip every line that doesn't start with dup, and require the
 *   format of the dup lines to be precisely as shown, with one
 *   per line.
 *
 *   This is different from what writet1 reads, and is not general
 *   PostScript, but it matches the format for almost every Type 1
 *   font I have seen including the existing cm bitmap fonts which
 *   makes extraction from those PFB files easy.  And it's code that
 *   is easy to write and unlikely to have bugs.
 */
#include <stdio.h>
#include <string.h>
#ifndef STANDALONE
#include <kpathsea/config.h>
#endif
#include "dvips.h"
#include "protos.h"
#include "bitmapenc.h"
/*
 *   Do we use this functionality?
 */
int encodetype3 = 1 ;
#ifdef STANDALONE
#undef fopen
#undef fclose
#endif
#define ENCODING_CHAR_COUNT 256
#define MAX_LINE_LENGTH 256
/*
 *   Some fonts claim to use the StandardEncoding.  Whether they do or not,
 *   we believe them, and use this magic constant to indicate this.  Note
 *   that this is a magic constant, and cannot be interpreted as an array
 *   of 256 strings as all other encodings are.
 */
const char *static_standard_encoding = "StandardEncoding" ;
const char **STANDARD_ENCODING = &static_standard_encoding ;
/*
 *   Parse the encoding file.  If use_all flag is set then we are parsing
 *   the dvips_all file which can have multiple encodings, each preceded
 *   by a set of lines with font names followed by a colon character.
 *
 *   If we are parsing them all, we build a sorted global list of entries
 *   for later lookup, and always return 0.  Otherwise we just expect a
 *   single encoding and we store that away.
 */
static int numstatic, capstatic, namedstatic ;
static struct allfontenc {
   const char *fontname ;
   const char **enc ;
} *bmfontarr ;
static void add_fontname(const char *fontname) {
   if (namedstatic >= capstatic) {
      int ncapstatic = capstatic * 2 + 20 ;
      struct allfontenc *nbmfontarr =
          (struct allfontenc *)mymalloc(sizeof(struct allfontenc) * ncapstatic) ;
      if (capstatic) {
         memcpy(nbmfontarr, bmfontarr, sizeof(struct allfontenc)*capstatic) ;
         free(bmfontarr) ;
      }
      bmfontarr = nbmfontarr ;
      for (int i=capstatic; i<ncapstatic; i++) {
         bmfontarr[i].fontname = 0 ;
         bmfontarr[i].enc = 0 ;
      }
      capstatic = ncapstatic ;
   }
   bmfontarr[namedstatic].fontname = fontname ;
   bmfontarr[namedstatic].enc = 0 ;
   namedstatic++ ;
}
static void fillup_static(const char **e) {
   while (numstatic < namedstatic)
      bmfontarr[numstatic++].enc = e ;
}
static const char **parseencoding(FILE *f, int use_all) {
   char encbuf[MAX_LINE_LENGTH+1] ;
   for (int i=0; i<sizeof(encbuf); i++)
      encbuf[i] = 0 ;
   int characters_loaded = 0 ;
   const char **e = 0 ;
   while (fgets(encbuf, MAX_LINE_LENGTH, f) != 0) {
      char *p = encbuf ;
      char *q = p ;
      while (*q && *q != ':')
         q++ ;
      if (*q == ':') { // looks like a font name
         if (q[1] >= ' ' || !use_all)
            error("! unexpected colon or extra stuff at end of line in encoding file?") ;
         if (e)
            error("! unfinished encoding?") ;
         *q = 0 ;
         add_fontname(strdup(p)) ;
      } else if (strncmp(p, "/Encoding", 9) == 0) { // check for StandardEncoding
         p += 9 ;
         while (*p && *p <= ' ')
            p++ ;
         if (strncmp(p, "StandardEncoding", 16) == 0) {
            e = STANDARD_ENCODING ;
            if (use_all) {
               fillup_static(e) ;
               e = 0 ;
            } else
               return e ;
         } else {
            e = (const char **)
                      mymalloc(sizeof(const char *)*ENCODING_CHAR_COUNT) ;
            for (int i=0; i<ENCODING_CHAR_COUNT; i++)
               e[i] = 0 ;
         }
         characters_loaded = 0 ;
      } else if (strncmp(p, "dup", 3) == 0) { // possible line; parse it out
         p += 3 ;
         const char *err = 0 ;
         if (e == 0)
            err = "dup line before Encoding line" ;
         if (e == STANDARD_ENCODING)
            err = "dup line after STANDARD_ENCODING line" ;
         char *charname = 0 ;
         int charnum = 0 ;
         if (err == 0) do { // do/while(0); let us break to an error routine
            if (*p != ' ' && *p != '\t') {
               err = "Missing whitespace after dup line" ;
               break ;
            }
            while (*p == ' ' || *p == '\t')
               p++ ;
            int dig = 0 ;
            if ('0' > *p || *p > '9') {
               err = "Missing number after dup" ;
               break ;
            }
            while ('0' <= *p && *p <= '9') {
               dig = 10 * dig + *p++ - '0' ;
               if (dig > 255)
                  break ;
            }
            if (dig > 255) {
               err = "Code value too large" ;
               break ;
            }
            if (e[dig] != 0) {
               err = "Duplicated code value" ;
               break ;
            }
            charnum = dig ;
            while (*p == ' ' || *p == '\t')
               p++ ;
            if (*p != '/') {
               err = "Glyph name must start with slash" ;
               break ;
            }
            charname = p++ ;
            // PostScript names can be anything but the basic
            // delimiters ()[]{}<>/%.
            while (*p > ' ' && 0 == strchr("[]{}()<>/%", *p))
               p++ ;
            if (p == charname + 1) {
               err = "Empty glyph name" ;
               break ;
            }
            if (*p != ' ' && *p != '\t') {
               err = "Missing whitespace after glyph name" ;
               break ;
            }
            *p++ = 0 ; // terminate the charname string and munge the buffer
            while (*p == ' ' || *p == '\t')
               p++ ;
            if (strncmp(p, "put", 3) != 0) {
               err = "Missing put after glyph name" ;
               break ;
            }
            p += 3 ;
            while (*p == ' ' || *p == '\t')
               p++ ;
            if (*p != 0 && *p != 10 && *p != 13 && *p != '%') {
               err = "Extra stuff after put" ;
               break ;
            }
         } while (0) ; // allow break for errors
         if (err) {
            strcpy(encbuf, "! Reading bitmap encoding file failed: ") ;
            strcat(encbuf, err) ;
            error(encbuf) ;
         }
         if (strcmp(charname, "/.notdef") == 0)
            e[charnum] = 0 ;
         else {
            characters_loaded++ ;
            e[charnum] = strdup(charname) ;
            if (e[charnum] == 0)
               error("! ran out of memory reading bitmap encoding") ;
         }
      } else if (strncmp(p, "readonly", 8) == 0) { // end of encoding
         if (use_all) {
            if (characters_loaded == 0 && e != STANDARD_ENCODING)
               error("! did not find any valid character definitions in encoding file") ;
            fillup_static(e) ;
            e = 0 ;
         }
      }
   }
   if (use_all) {
      // sort the static fonts for quicker search; Shell sort
      int h = 1 ;
      while (h < numstatic)
         h = 3 * h + 1 ;
      while (h > 1) {
         h /= 3 ;
         for (int i=h; i<numstatic; i++) {
            int j = i ;
            while (j >= h &&
                   strcmp(bmfontarr[j-h].fontname, bmfontarr[j].fontname) > 0) {
               const char *na = bmfontarr[j-h].fontname ;
               const char **en = bmfontarr[j-h].enc ;
               bmfontarr[j-h].fontname = bmfontarr[j].fontname ;
               bmfontarr[j-h].enc = bmfontarr[j].enc ;
               bmfontarr[j].fontname = na ;
               bmfontarr[j].enc = en ;
               j -= h ;
            }
         }
      }
      return 0 ;
   } else {
      if (characters_loaded == 0 && e != STANDARD_ENCODING)
         error("! did not find any valid character definitions in encoding file") ;
      return e ;
   }
}
/*
 *   Given a font name, find an encoding file.
 */
#define MAX_NAME_SIZE 256
static FILE *bitmap_enc_search(const char *fontname) {
   char namebuf[MAX_NAME_SIZE+1] ;
   if (fontname == 0 || strlen(fontname) > 128)
      error("! excessively long font name") ;
   sprintf(namebuf, "dvips-%s.enc", fontname) ;
#ifdef STANDALONE
   return fopen(namebuf, FOPEN_RBIN_MODE) ;
#else
   return search(kpse_enc_format, namebuf, FOPEN_RBIN_MODE) ;
#endif
}
/*
 *   Are two raw encodings identical?
 */
static int eqencoding(const char **a, const char **b) {
   if (a == b)
      return 1 ;
   if (a == STANDARD_ENCODING || b == STANDARD_ENCODING)
      return 0 ;
   for (int i=0; i<ENCODING_CHAR_COUNT; i++)
      if (a[i] != b[i] && (a[i] == 0 || b[i] == 0 || strcmp(a[i], b[i]) != 0))
         return 0 ;
   return 1 ;
}
/*
 *   Our list of encodings we've seen.
 */
static struct bmenc *bmlist ;
/*
 *   Add an encoding to our list.
 */
struct bmenc *addbmenc(const char **enc) {
   struct bmenc *r = (struct bmenc *)mymalloc(sizeof(struct bmenc)) ;
   r->downloaded_seq = -1 ;
   r->enc = enc ;
   r->next = bmlist ;
   bmlist = r ;
   return r ;
}
/*
 *   Given a particular encoding, walk through our encoding list and
 *   see if it already exists; if so, return the existing one and
 *   drop the new one.  The set of distinct encodings in a particular
 *   document is expected to be small (a few dozen at most).
 */
static struct bmenc *deduplicateencoding(const char **enc) {
   for (struct bmenc *p=bmlist; p!=0; p=p->next)
      if (eqencoding(p->enc, enc))
         return p ;
   return addbmenc(enc) ;
}
static const char **bitmap_enc_load(const char *fontname, int use_all) {
   FILE *f = bitmap_enc_search(use_all ? "all" : fontname) ;
   if (f != 0) {
      const char **r = parseencoding(f, use_all) ;
      fclose(f) ;
      return r ;
   }
   return 0 ;
}
/*
 *   Start a section: say we didn't download anything.
 */
static int curbmseq ;
void bmenc_startsection() {
   for (struct bmenc *p=bmlist; p!=0; p=p->next)
      p->downloaded_seq = -1 ;
   curbmseq = 0 ;
}
/*
 *   Try to find a font in the all encoding list.  This list is sorted
 *   so we can use binary search.
 */
static const char **bitmap_all_find(const char *fontname) {
   int ptr = 0 ;
   int bit = 1 ;
   while ((bit << 1) < numstatic)
      bit <<= 1 ;
   while (bit > 0) {
      int t = ptr + bit ;
      if (t < numstatic && strcmp(fontname, bmfontarr[t].fontname) >= 0)
         ptr = t ;
      bit >>= 1 ;
   }
   if (strcmp(fontname, bmfontarr[ptr].fontname) == 0)
      return bmfontarr[ptr].enc ;
   else
      return 0 ;
}
/*
 *   Download the encoding and set the sequence number.
 */
static void downloadenc(struct bmenc *enc) {
   if (enc->enc == STANDARD_ENCODING)
      return ;
   char encname[10] ;
   sprintf(encname, "/EN%d", curbmseq) ;
   newline() ; // someone may want to cut/paste the encodings
   psnameout(encname) ;
   specialout('[') ;
   for (int i=0; i<ENCODING_CHAR_COUNT; i++) {
      int notdef = 0 ;
      while (i+notdef<ENCODING_CHAR_COUNT && enc->enc[i+notdef]==0)
         notdef++ ;
      if (notdef > 2) {
         numout(notdef);
         specialout('{') ;
         psnameout("/.notdef") ;
         specialout('}') ;
         cmdout("repeat") ;
         i += notdef - 1 ;
      } else if (notdef) {
         psnameout("/.notdef") ;
      } else {
         psnameout(enc->enc[i]) ;
      }
   }
   specialout(']') ;
   cmdout("N") ;
   newline() ;
   enc->downloaded_seq = curbmseq++ ;
}
/*
 *   This is the list of fonts we have seen so far.
 */
struct bmfontenc *bmfontenclist ;
/*
 *   We warn if we have to use a built-in encoding, and set this value to 1.
 *   We warn again if we cannot find a built-in encoding and have to
 *   default to StandardEncoding, and set this value to 2.
 */
static int warned_about_missing_encoding = 0 ;
/*
 *   Print a warning message.
 */
static void bmenc_warn(const char *fontname, const char *msg) {
   fprintf(stderr,
       "dvips: Static bitmap font encoding for font %s (and others?): %s.\n",
                   fontname, msg) ;
}
/*
 *   About to download a font; find the encoding sequence number.
 *   If needed, download a new sequence.  If we can't find one, use
 *   -1; this font will not work for copy/paste.  If it is
 *   STANDARD_ENCODING, return the magic value for that.
 */
static int tried_all = 0 ; // have we tried to load dvips-all.enc
int getencoding_seq(const char *fontname) {
   struct bmenc *enc = 0 ;
   struct bmfontenc *p = bmfontenclist ;
   for (; p!=0; p=p->next)
      if (strcmp(fontname, p->fontname) == 0) {
         enc = p->enc ;
         if (enc == 0) // remember failures
            return -1 ;
         break ;
      }
   // not in list; try to load it from a file
   if (enc == 0) {
      const char **e = bitmap_enc_load(fontname, 0) ;
      // did not find it; try to load it from the dvips-all list.
      if (e == 0) {
         if (!tried_all) {
            bitmap_enc_load(fontname, 1) ;
            tried_all = 1 ;
         }
         e = bitmap_all_find(fontname) ;
      }
      if (e)
         enc = deduplicateencoding(e) ;
   }
   // did not find this in the list; add it to the list
   if (p == 0) {
      p = (struct bmfontenc *)mymalloc(sizeof(struct bmfontenc)) ;
      p->fontname = strdup(fontname) ;
      p->enc = enc ;
      p->next = bmfontenclist ;
      bmfontenclist = p ;
   }
   if (enc == 0) {
      if (warned_about_missing_encoding < 2) {
         bmenc_warn(fontname, "no match in static list; not encoding") ;
         warned_about_missing_encoding = 2 ;
      }
      return -1 ; // don't download an encoding
   }
   if (enc->enc == STANDARD_ENCODING)
      return STANDARD_ENCODING_SEQ_MAGIC ;
   if (enc->downloaded_seq < 0)
      downloadenc(enc) ;
   return enc->downloaded_seq ;
}
#ifdef STANDALONE
/*
 *   Standalone test code:
 */
void error(const char *s) {
   fprintf(stderr, "Failed: %s\n", s) ;
   if (*s == '!')
      exit(0) ;
}
char *mymalloc(int sz) {
   return (char *)malloc(sz) ;
}
int pos = 0 ;
int idok = 1 ;
const int MAXLINE = 75 ;
void newline() {
   printf("\n") ;
   idok = 1 ;
   pos = 0 ;
}
void numout(int num) {
   int len = 1 ;
   int t = num / 10 ;
   while (t>0) {
      len++ ;
      t /= 10 ;
   }
   if (pos + len >= MAXLINE)
      newline() ;
   if (!idok)
      specialout(' ') ;
   printf("%d", num) ;
   pos += len ;
   idok = 0 ;
}
void cmdout(const char *s) {
   if (pos + strlen(s) >= MAXLINE)
      newline() ;
   if (*s != '/' && !idok)
      specialout(' ') ;
   printf("%s", s) ;
   pos += strlen(s) ;
   idok = 0 ;
}
void psnameout(const char *s) {
   cmdout(s) ;
}
void specialout(char c) {
   if (pos + 1 >= MAXLINE)
      newline() ;
   printf("%c", c) ;
   pos++ ;
   idok = 1 ;
}
int main(int argc, char *argv[]) {
   bmenc_startsection() ;
   for (int i=1; i<argc; i++) {
      int r = getencoding_seq(argv[i]) ;
      printf("Result for %s is %d\n", argv[i], r) ;
   }
}
#endif
